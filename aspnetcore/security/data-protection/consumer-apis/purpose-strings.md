---
title: "Chaînes d’objectif"
author: rick-anderson
description: "Ce document décrit en détail comment les chaînes de fin sont utilisées dans l’API de protection des données ASP.NET Core."
keywords: "ASP.NET Core, protection des données, les chaînes d’objectif"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: c96ed361-c382-4980-8933-800e740cfc38
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 0d759937703d2a25604042b5e74e71155d635c1b
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/10/2017
---
# <a name="purpose-strings"></a><span data-ttu-id="5459d-104">Chaînes d’objectif</span><span class="sxs-lookup"><span data-stu-id="5459d-104">Purpose Strings</span></span>

<a name="data-protection-consumer-apis-purposes"></a>

<span data-ttu-id="5459d-105">Les composants qui consomment `IDataProtectionProvider` doit passer un unique *à des fins* paramètre à la `CreateProtector` (méthode).</span><span class="sxs-lookup"><span data-stu-id="5459d-105">Components which consume `IDataProtectionProvider` must pass a unique *purposes* parameter to the `CreateProtector` method.</span></span> <span data-ttu-id="5459d-106">Les besoins *paramètre* est inhérent à la sécurité du système de protection de données, car il fournit une isolation entre les consommateurs de services de chiffrement, même si les clés de chiffrement racine sont les mêmes.</span><span class="sxs-lookup"><span data-stu-id="5459d-106">The purposes *parameter* is inherent to the security of the data protection system, as it provides isolation between cryptographic consumers, even if the root cryptographic keys are the same.</span></span>

<span data-ttu-id="5459d-107">Lorsqu’un consommateur spécifie un objectif, la chaîne de l’objet est utilisée, ainsi que les clés de chiffrement racine pour dériver des sous-clés de chiffrement uniques pour ce consommateur.</span><span class="sxs-lookup"><span data-stu-id="5459d-107">When a consumer specifies a purpose, the purpose string is used along with the root cryptographic keys to derive cryptographic subkeys unique to that consumer.</span></span> <span data-ttu-id="5459d-108">Cela permet d’isoler le consommateur à partir de tous les autres consommateurs de services de chiffrement dans l’application : aucun autre composant ne peut lire les charges utiles, et il ne peut pas lire les charges de tout autre composant.</span><span class="sxs-lookup"><span data-stu-id="5459d-108">This isolates the consumer from all other cryptographic consumers in the application: no other component can read its payloads, and it cannot read any other component's payloads.</span></span> <span data-ttu-id="5459d-109">Cette isolation rend également irréalisable différentes catégories d’attaque par rapport au composant.</span><span class="sxs-lookup"><span data-stu-id="5459d-109">This isolation also renders infeasible entire categories of attack against the component.</span></span>

![Exemple de diagramme d’objectif](purpose-strings/_static/purposes.png)

<span data-ttu-id="5459d-111">Dans le diagramme ci-dessus, `IDataProtector` instances A et B **ne peut pas** chacune des charges utiles, uniquement de lire leurs propres.</span><span class="sxs-lookup"><span data-stu-id="5459d-111">In the diagram above, `IDataProtector` instances A and B **cannot** read each other's payloads, only their own.</span></span>

<span data-ttu-id="5459d-112">La chaîne de l’objet ne peut être divulgué.</span><span class="sxs-lookup"><span data-stu-id="5459d-112">The purpose string doesn't have to be secret.</span></span> <span data-ttu-id="5459d-113">Il doit simplement être unique dans le sens qu’aucun autre composant valide ne fournira jamais la même chaîne de l’objet.</span><span class="sxs-lookup"><span data-stu-id="5459d-113">It should simply be unique in the sense that no other well-behaved component will ever provide the same purpose string.</span></span>

>[!TIP]
> <span data-ttu-id="5459d-114">À l’aide de l’espace de noms et nom de type du composant de consommation de l’API de protection des données est une règle empirique, comme dans les exercices pratiques de que ces informations ne seront jamais en conflit.</span><span class="sxs-lookup"><span data-stu-id="5459d-114">Using the namespace and type name of the component consuming the data protection APIs is a good rule of thumb, as in practice this information will never conflict.</span></span>
>
><span data-ttu-id="5459d-115">Un composant créé par Contoso qui est responsable de minting des jetons de support peut utiliser Contoso.Security.BearerToken comme chaîne de son objectif.</span><span class="sxs-lookup"><span data-stu-id="5459d-115">A Contoso-authored component which is responsible for minting bearer tokens might use Contoso.Security.BearerToken as its purpose string.</span></span> <span data-ttu-id="5459d-116">Ou - plus -, il peut utiliser Contoso.Security.BearerToken.v1 en tant que chaîne de son objectif.</span><span class="sxs-lookup"><span data-stu-id="5459d-116">Or - even better - it might use Contoso.Security.BearerToken.v1 as its purpose string.</span></span> <span data-ttu-id="5459d-117">Ajoutez le numéro de version permet à une version ultérieure utiliser Contoso.Security.BearerToken.v2 comme son objectif et les différentes versions seraient totalement isolées les unes des autres aussi loin que charges utiles.</span><span class="sxs-lookup"><span data-stu-id="5459d-117">Appending the version number allows a future version to use Contoso.Security.BearerToken.v2 as its purpose, and the different versions would be completely isolated from one another as far as payloads go.</span></span>

<span data-ttu-id="5459d-118">Depuis le paramètre à des fins de `CreateProtector` est un tableau de chaînes, ci-dessus pourrait ont été plutôt spécifiés en tant que `[ "Contoso.Security.BearerToken", "v1" ]`.</span><span class="sxs-lookup"><span data-stu-id="5459d-118">Since the purposes parameter to `CreateProtector` is a string array, the above could have been instead specified as `[ "Contoso.Security.BearerToken", "v1" ]`.</span></span> <span data-ttu-id="5459d-119">Cela permet l’établissement d’une hiérarchie des objectifs et ouvrez la possibilité d’une architecture mutualisées des scénarios avec le système de protection des données.</span><span class="sxs-lookup"><span data-stu-id="5459d-119">This allows establishing a hierarchy of purposes and opens up the possibility of multi-tenancy scenarios with the data protection system.</span></span>

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> <span data-ttu-id="5459d-120">Composants ne doivent pas permettre d’entrée d’utilisateur non fiable être la seule source d’entrée pour la chaîne à des fins.</span><span class="sxs-lookup"><span data-stu-id="5459d-120">Components should not allow untrusted user input to be the sole source of input for the purposes chain.</span></span>
>
><span data-ttu-id="5459d-121">Par exemple, considérez un composant Contoso.Messaging.SecureMessage qui est responsable du stockage des messages sécurisés.</span><span class="sxs-lookup"><span data-stu-id="5459d-121">For example, consider a component Contoso.Messaging.SecureMessage which is responsible for storing secure messages.</span></span> <span data-ttu-id="5459d-122">Si le composant de messagerie sécurisé devait appeler `CreateProtector([ username ])`, puis un utilisateur malveillant peut créer un compte avec un nom d’utilisateur « Contoso.Security.BearerToken » dans la tentative d’obtention du composant à appeler `CreateProtector([ "Contoso.Security.BearerToken" ])`, donc par inadvertance à l’origine de la messagerie sécurisée système de charges utiles de monnaies qui peut être perçu comme les jetons d’authentification.</span><span class="sxs-lookup"><span data-stu-id="5459d-122">If the secure messaging component were to call `CreateProtector([ username ])`, then a malicious user might create an account with username "Contoso.Security.BearerToken" in an attempt to get the component to call `CreateProtector([ "Contoso.Security.BearerToken" ])`, thus inadvertently causing the secure messaging system to mint payloads that could be perceived as authentication tokens.</span></span>
>
><span data-ttu-id="5459d-123">Une chaîne à des fins de meilleures pour le composant de messagerie serait `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, qui fournit d’isolation appropriée.</span><span class="sxs-lookup"><span data-stu-id="5459d-123">A better purposes chain for the messaging component would be `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, which provides proper isolation.</span></span>

<span data-ttu-id="5459d-124">L’isolation assurée par et les comportements de `IDataProtectionProvider`, `IDataProtector`, et à des fins de sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="5459d-124">The isolation provided by and behaviors of `IDataProtectionProvider`, `IDataProtector`, and purposes are as follows:</span></span>

* <span data-ttu-id="5459d-125">Pour une donnée `IDataProtectionProvider` objet, le `CreateProtector` méthode crée une `IDataProtector` objet exclusivement liés à la fois à la `IDataProtectionProvider` l’objet qui a créé et le paramètre à des fins qui a été passé dans la méthode.</span><span class="sxs-lookup"><span data-stu-id="5459d-125">For a given `IDataProtectionProvider` object, the `CreateProtector` method will create an `IDataProtector` object uniquely tied to both the `IDataProtectionProvider` object which created it and the purposes parameter which was passed into the method.</span></span>

* <span data-ttu-id="5459d-126">Le paramètre d’objet ne doit pas être null.</span><span class="sxs-lookup"><span data-stu-id="5459d-126">The purpose parameter must not be null.</span></span> <span data-ttu-id="5459d-127">(Si à des fins est spécifié sous forme de tableau, cela signifie que le tableau ne doit pas être de longueur nulle, et tous les éléments du tableau doivent être non null.) Un objectif de la chaîne vide est autorisée techniquement mais est déconseillé.</span><span class="sxs-lookup"><span data-stu-id="5459d-127">(If purposes is specified as an array, this means that the array must not be of zero length and all elements of the array must be non-null.) An empty string purpose is technically allowed but is discouraged.</span></span>

* <span data-ttu-id="5459d-128">Arguments de deux objectifs sont équivalentes si et seulement si elles contiennent les mêmes chaînes (à l’aide d’un comparateur ordinal) dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="5459d-128">Two purposes arguments are equivalent if and only if they contain the same strings (using an ordinal comparer) in the same order.</span></span> <span data-ttu-id="5459d-129">Un argument de fonction unique est équivalent à la baie à des fins de l’élément correspondant.</span><span class="sxs-lookup"><span data-stu-id="5459d-129">A single purpose argument is equivalent to the corresponding single-element purposes array.</span></span>

* <span data-ttu-id="5459d-130">Deux `IDataProtector` objets sont équivalents si et seulement si elles sont créées à partir de l’équivalent `IDataProtectionProvider` objets avec des paramètres à des fins équivalentes.</span><span class="sxs-lookup"><span data-stu-id="5459d-130">Two `IDataProtector` objects are equivalent if and only if they are created from equivalent `IDataProtectionProvider` objects with equivalent purposes parameters.</span></span>

* <span data-ttu-id="5459d-131">Pour une donnée `IDataProtector` objet, un appel à `Unprotect(protectedData)` l’original `unprotectedData` si et seulement si `protectedData := Protect(unprotectedData)` pour un équivalent `IDataProtector` objet.</span><span class="sxs-lookup"><span data-stu-id="5459d-131">For a given `IDataProtector` object, a call to `Unprotect(protectedData)` will return the original `unprotectedData` if and only if `protectedData := Protect(unprotectedData)` for an equivalent `IDataProtector` object.</span></span>

> [!NOTE]
> <span data-ttu-id="5459d-132">Nous envisageons pas le cas où un composant choisit intentionnellement une chaîne de l’objectif qui est en conflit avec un autre composant.</span><span class="sxs-lookup"><span data-stu-id="5459d-132">We're not considering the case where some component intentionally chooses a purpose string which is known to conflict with another component.</span></span> <span data-ttu-id="5459d-133">Un tel composant essentiellement est considéré comme malveillant, et ce système n’est pas destiné à fournir des garanties de sécurité dans le cas où un code malveillant est déjà en cours d’exécution à l’intérieur du processus de travail.</span><span class="sxs-lookup"><span data-stu-id="5459d-133">Such a component would essentially be considered malicious, and this system is not intended to provide security guarantees in the event that malicious code is already running inside of the worker process.</span></span>
